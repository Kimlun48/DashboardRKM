import {
  require_react_dom
} from "./chunk-5OZJXOSV.js";
import {
  require_react
} from "./chunk-K5YNGTCN.js";
import {
  __toESM
} from "./chunk-ZC22LKFR.js";

// node_modules/react-text-to-speech/dist/index.js
var import_react4 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());

// node_modules/react-text-to-speech/dist/hooks.js
var import_react2 = __toESM(require_react(), 1);

// node_modules/react-text-to-speech/dist/utils.js
var import_react = __toESM(require_react(), 1);
function ArrayToText(element) {
  if (typeof element === "string")
    return element;
  return element.map(ArrayToText).join(" ") + " ";
}
function JSXToArray(element) {
  if ((0, import_react.isValidElement)(element)) {
    const { children } = element.props;
    if (Array.isArray(children))
      return children.map(JSXToArray);
    return JSXToArray(children);
  }
  return typeof element === "string" ? element : typeof element === "number" ? String(element) : "";
}
function cancel() {
  var _a;
  if (typeof window !== "undefined")
    (_a = window.speechSynthesis) === null || _a === void 0 ? void 0 : _a.cancel();
}
function findCharIndex(words, index) {
  let currentIndex = 0;
  function recursiveSearch(stringArray, parentIndex = "") {
    if (typeof stringArray === "string") {
      const elementIndex = index - currentIndex;
      return (currentIndex += stringArray.length + 1) > index ? getIndex(parentIndex, elementIndex) : "";
    }
    for (let i = 0; i < stringArray.length; i++) {
      const element = stringArray[i];
      const result = recursiveSearch(element, i);
      if (result)
        return getIndex(parentIndex, result);
    }
    currentIndex++;
    return "";
  }
  return recursiveSearch(words);
}
var getIndex = (parentIndex, index) => `${parentIndex === "" ? "" : parentIndex + "-"}${index}`;
function isParent(parentIndex, index) {
  if (!(index === null || index === void 0 ? void 0 : index.startsWith(parentIndex)))
    return false;
  if (parentIndex) {
    const indexParts = index.split("-");
    const parentIndexParts = parentIndex.split("-");
    for (let i = 0; i < parentIndexParts.length; i++) {
      if (indexParts[i] !== parentIndexParts[i])
        return false;
    }
  }
  return true;
}
var sanitize = (text) => text.replace(/[<>]|(&[^\s;]+);/g, (match, group) => match === "<" ? "(" : (group || "") + ")");

// node_modules/react-text-to-speech/dist/queue.js
var queue = [];
var queueListeners = [];
function clearQueue(cancelSpeech = false, start = 0, emitEvent = false) {
  if (cancelSpeech)
    cancel();
  queue.slice(start).forEach(({ setSpeechStatus }) => setSpeechStatus("stopped"));
  queue.length = 0;
  if (emitEvent)
    emit();
}
function addToQueue(item, callback) {
  queue.push(item);
  emit(callback);
}
var clearQueueHook = () => clearQueue(true, 1, true);
var clearQueueUnload = () => clearQueue(true, 1);
function dequeue(index = 0) {
  if (index === 0)
    cancel();
  else
    removeFromQueue(index);
}
function emit(callback) {
  const utteranceQueue = queue.map(({ utterance }) => utterance);
  queueListeners.forEach((listener) => listener(utteranceQueue));
  callback === null || callback === void 0 ? void 0 : callback(utteranceQueue);
}
function removeFromQueue(utterance, callback) {
  const index = typeof utterance === "number" ? utterance : queue.findIndex((item2) => item2.utterance === utterance);
  if (index === -1)
    return;
  const [item] = queue.splice(index, 1);
  if (item) {
    item.setSpeechStatus("stopped");
    emit(callback);
  }
}
function speakFromQueue() {
  const item = queue[0];
  if (item)
    window.speechSynthesis.speak(item.utterance);
}
function subscribe(callback) {
  queueListeners.push(callback);
  return () => {
    const index = queueListeners.indexOf(callback);
    if (index !== -1)
      queueListeners.splice(index, 1);
  };
}

// node_modules/react-text-to-speech/dist/hooks.js
function useQueue() {
  const [queue2, setQueue] = (0, import_react2.useState)([]);
  (0, import_react2.useEffect)(() => subscribe(setQueue), []);
  return { queue: queue2, dequeue, clearQueue: clearQueueHook };
}
function useSpeech({ text, pitch = 1, rate = 1, volume = 1, lang, voiceURI, highlightText = false, highlightProps, preserveUtteranceQueue = false, onError = console.error, onStart, onResume, onPause, onStop, onBoundary, onQueueChange }) {
  const [speechStatus, speechStatusRef, setSpeechStatus] = useStateRef("stopped");
  const [speakingWord, setSpeakingWord] = (0, import_react2.useState)();
  const utteranceRef = (0, import_react2.useRef)();
  const { voices } = useVoices();
  const [words, stringifiedWords] = (0, import_react2.useMemo)(() => {
    const words2 = JSXToArray(text);
    return [words2, JSON.stringify(words2)];
  }, [text]);
  function start() {
    const synth = window.speechSynthesis;
    if (!synth)
      return onError(new Error("Browser not supported! Try some other browser."));
    if (speechStatus === "paused")
      return synth.resume();
    if (speechStatus === "queued")
      return;
    const utterance = new SpeechSynthesisUtterance(sanitize(ArrayToText(words)));
    utterance.pitch = pitch;
    utterance.rate = rate;
    utterance.volume = volume;
    if (lang)
      utterance.lang = lang;
    if (voiceURI) {
      if (!Array.isArray(voiceURI))
        voiceURI = [voiceURI];
      for (let i = 0; i < voiceURI.length; i++) {
        const uri = voiceURI[i];
        const voice = voices.find((voice2) => voice2.voiceURI === uri);
        if (voice) {
          utterance.voice = voice;
          break;
        }
      }
    }
    const stopEventHandler = (event) => {
      if (synth.paused)
        cancel();
      window.removeEventListener("beforeunload", clearQueueUnload);
      setSpeechStatus("stopped");
      setSpeakingWord(null);
      utterance.onstart = null;
      utterance.onresume = null;
      utterance.onpause = null;
      utterance.onend = null;
      utterance.onerror = null;
      utterance.onboundary = null;
      removeFromQueue(utterance, onQueueChange);
      speakFromQueue();
      onStop === null || onStop === void 0 ? void 0 : onStop(event);
    };
    utterance.onstart = (event) => {
      window.addEventListener("beforeunload", clearQueueUnload);
      setSpeechStatus("started");
      onStart === null || onStart === void 0 ? void 0 : onStart(event);
    };
    utterance.onresume = (event) => {
      setSpeechStatus("started");
      onResume === null || onResume === void 0 ? void 0 : onResume(event);
    };
    utterance.onpause = (event) => {
      setSpeechStatus("paused");
      onPause === null || onPause === void 0 ? void 0 : onPause(event);
    };
    utterance.onend = stopEventHandler;
    utterance.onerror = stopEventHandler;
    utterance.onboundary = (event) => {
      setSpeakingWord({ index: findCharIndex(words, event.charIndex), length: event.charLength });
      onBoundary === null || onBoundary === void 0 ? void 0 : onBoundary(event);
    };
    if (!preserveUtteranceQueue)
      clearQueue();
    addToQueue({ utterance, setSpeechStatus }, onQueueChange);
    if (synth.speaking) {
      if (preserveUtteranceQueue && speechStatus !== "started") {
        utteranceRef.current = utterance;
        return setSpeechStatus("queued");
      } else
        cancel();
    } else
      speakFromQueue();
    setSpeechStatus("started");
  }
  function pause() {
    var _a;
    if (speechStatus === "started")
      return (_a = window.speechSynthesis) === null || _a === void 0 ? void 0 : _a.pause();
    if (speechStatus === "queued")
      stop();
  }
  function stop(status = speechStatus) {
    if (status === "stopped")
      return;
    if (status !== "queued")
      return cancel();
    removeFromQueue(utteranceRef.current, onQueueChange);
    setSpeechStatus("stopped");
  }
  function highlightedText(element, parentIndex = "") {
    var _a;
    if (!highlightText || !isParent(parentIndex, speakingWord === null || speakingWord === void 0 ? void 0 : speakingWord.index))
      return element;
    if (Array.isArray(element))
      return element.map((child, index) => highlightedText(child, getIndex(parentIndex, index)));
    if ((0, import_react2.isValidElement)(element))
      return (0, import_react2.cloneElement)(element, { key: (_a = element.key) !== null && _a !== void 0 ? _a : Math.random() }, highlightedText(element.props.children, parentIndex));
    if (typeof element === "string" || typeof element === "number") {
      element = String(element);
      const { index, length } = speakingWord;
      const before = element.slice(0, +index.split("-").at(-1)).length;
      return import_react2.default.createElement(
        "span",
        { key: index },
        element.slice(0, before),
        import_react2.default.createElement("mark", Object.assign({}, highlightProps), element.slice(before, before + length)),
        element.slice(before + length)
      );
    }
    return element;
  }
  (0, import_react2.useEffect)(() => {
    return () => stop(speechStatusRef.current);
  }, [stringifiedWords]);
  return {
    Text: () => highlightedText(text),
    speechStatus,
    isInQueue: speechStatus === "started" || speechStatus === "queued",
    start,
    pause,
    stop: () => stop()
  };
}
function useStateRef(init) {
  const [state, setState] = (0, import_react2.useState)(init);
  const ref = (0, import_react2.useRef)(init);
  function setStateRef(value) {
    ref.current = value;
    setState(value);
  }
  return [state, ref, setStateRef];
}
function useVoices() {
  const [languages, setLanguages] = (0, import_react2.useState)([]);
  const [voices, setVoices] = (0, import_react2.useState)([]);
  function setData(voices2) {
    setLanguages([...new Set(voices2.map(({ lang }) => lang))]);
    setVoices(voices2);
  }
  (0, import_react2.useEffect)(() => {
    const synth = window.speechSynthesis;
    if (!synth)
      return;
    const voices2 = synth.getVoices();
    if (voices2.length)
      setData(voices2);
    else {
      const onVoicesChanged = () => setData(synth.getVoices());
      synth.addEventListener("voiceschanged", onVoicesChanged);
      return () => synth.removeEventListener("voiceschanged", onVoicesChanged);
    }
  }, []);
  return { languages, voices };
}

// node_modules/react-text-to-speech/dist/icons.js
var import_react3 = __toESM(require_react(), 1);
function HiMiniStop(props) {
  return import_react3.default.createElement(
    "span",
    Object.assign({}, props),
    import_react3.default.createElement(
      "svg",
      { viewBox: "0 0 20 20", fill: "currentColor", "aria-hidden": true, width: "1.25rem", height: "1.25rem" },
      import_react3.default.createElement("path", { d: "M5.25 3A2.25 2.25 0 003 5.25v9.5A2.25 2.25 0 005.25 17h9.5A2.25 2.25 0 0017 14.75v-9.5A2.25 2.25 0 0014.75 3h-9.5z" })
    )
  );
}
function HiVolumeOff(props) {
  return import_react3.default.createElement(
    "span",
    Object.assign({}, props),
    import_react3.default.createElement(
      "svg",
      { viewBox: "0 0 20 20", fill: "currentColor", "aria-hidden": true, width: "1.25rem", height: "1.25rem" },
      import_react3.default.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.707.707L4.586 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.586l3.707-3.707a1 1 0 011.09-.217zM12.293 7.293a1 1 0 011.414 0L15 8.586l1.293-1.293a1 1 0 111.414 1.414L16.414 10l1.293 1.293a1 1 0 01-1.414 1.414L15 11.414l-1.293 1.293a1 1 0 01-1.414-1.414L13.586 10l-1.293-1.293a1 1 0 010-1.414z" })
    )
  );
}
function HiVolumeUp(props) {
  return import_react3.default.createElement(
    "span",
    Object.assign({}, props),
    import_react3.default.createElement(
      "svg",
      { viewBox: "0 0 20 20", fill: "currentColor", "aria-hidden": true, width: "1.25rem", height: "1.25rem" },
      import_react3.default.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.707.707L4.586 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.586l3.707-3.707a1 1 0 011.09-.217zM14.657 2.929a1 1 0 011.414 0A9.972 9.972 0 0119 10a9.972 9.972 0 01-2.929 7.071 1 1 0 01-1.414-1.414A7.971 7.971 0 0017 10c0-2.21-.894-4.208-2.343-5.657a1 1 0 010-1.414zm-2.829 2.828a1 1 0 011.415 0A5.983 5.983 0 0115 10a5.984 5.984 0 01-1.757 4.243 1 1 0 01-1.415-1.415A3.984 3.984 0 0013 10a3.983 3.983 0 00-1.172-2.828 1 1 0 010-1.415z" })
    )
  );
}

// node_modules/react-text-to-speech/dist/index.js
var __rest = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
function HighlightedText(_a) {
  var { id, children } = _a, props = __rest(_a, ["id", "children"]);
  const [loading, setLoading] = (0, import_react4.useState)(true);
  (0, import_react4.useEffect)(() => {
    setLoading(false);
  }, []);
  return import_react4.default.createElement("div", Object.assign({ id: `rtts-${id}` }, props), loading && (typeof children === "string" ? import_react4.default.createElement("span", null, children) : children));
}
function Speech(_a) {
  var { id, startBtn = import_react4.default.createElement(HiVolumeUp, null), pauseBtn = import_react4.default.createElement(HiVolumeOff, null), stopBtn = import_react4.default.createElement(HiMiniStop, null), useStopOverPause = false, props = {}, children } = _a, hookProps = __rest(_a, ["id", "startBtn", "pauseBtn", "stopBtn", "useStopOverPause", "props", "children"]);
  const _b = useSpeech(hookProps), { Text } = _b, childrenOptions = __rest(_b, ["Text"]);
  const { isInQueue, start, pause, stop } = childrenOptions;
  const [highlightContainer, setHighlightContainer] = (0, import_react4.useState)(null);
  (0, import_react4.useEffect)(() => {
    if (hookProps.highlightText)
      setHighlightContainer(document.getElementById(`rtts-${id}`));
    else
      setHighlightContainer(null);
  }, [hookProps.highlightText]);
  return import_react4.default.createElement(
    import_react4.default.Fragment,
    null,
    typeof children === "function" ? children(childrenOptions) : import_react4.default.createElement(
      "div",
      Object.assign({ style: { display: "flex", columnGap: "1rem" } }, props),
      !isInQueue ? import_react4.default.createElement("span", { role: "button", onClick: start }, startBtn) : useStopOverPause ? import_react4.default.createElement("span", { role: "button", onClick: stop }, stopBtn) : import_react4.default.createElement("span", { role: "button", onClick: pause }, pauseBtn),
      !useStopOverPause && stopBtn && import_react4.default.createElement("span", { role: "button", onClick: stop }, stopBtn)
    ),
    highlightContainer && (0, import_react_dom.createPortal)(import_react4.default.createElement(Text, null), highlightContainer)
  );
}
export {
  HighlightedText,
  Speech as default,
  useQueue,
  useSpeech,
  useVoices
};
//# sourceMappingURL=react-text-to-speech.js.map
